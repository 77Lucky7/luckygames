<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LuckyBrawl</title>
  <style>body {
  margin: 0;
  padding: 0;
  font-family: Arial, sans-serif;
}

canvas {
  display: none;
  background-color: #000;
}

.screen {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
}

.hidden {
  display: none;
}

#brawlerList {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
}

.brawler {
  margin: 10px;
  cursor: pointer;
}

.brawler img {
  width: 100px;
  height: 100px;
}
    
#ammoBar, #healthBar, #enemyHealthBar {
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
     -khtml-user-select: none; /* Konqueror HTML */
       -moz-user-select: none; /* Old versions of Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently supported by Chrome, Edge, Opera, and Firefox */
}

</style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div id="titleScreen" class="screen">
    <h1>LuckyBrawl Remake</h1>
    <button onclick="startGame()">Select Character</button>
  </div>
  <div id="brawlerSelection" class="screen hidden">
    <h2>Choose Your Brawler</h2>
    <div id="brawlerList"></div>
    <!--><div id="trophyStatus">Trophy Status: 0</div></---!-->
    <div id="totalTrophies"></div>
  </div>
  <script>
// Brawler data (replace with actual data)
  
const brawlers = [
  { 
    name: "Brawler 1", 
    image: "brawler1.png", 
    mainAttack: { 
      description: "Shoots 2 bullets with moderately high damage, has 3 ammo, has 100 HP.", 
      action: shootBullets // Reference to main attack function
    },
    superAttack: { 
      description: "TBA", 
      action: launchRocket // Reference to super attack function
    }
  },
  { 
    name: "Brawler 2", 
    image: "brawler2.png", 
    mainAttack: { 
      description: "Shoots 3 bullets with low damage, has 5 ammo, has 85 HP. Shooting diagonally will decrease the spread between bullets.", 
      action: throwGrenades // Reference to main attack function
    },
    superAttack: { 
      description: "TBA", 
      action: callAirstrike // Reference to super attack function
    }
  },
  { 
    name: "Brawler 3", 
    image: "brawler3.png", 
    mainAttack: { 
      description: "This character is not available yet.",
      action: swingSword // Reference to main attack function
    },
    superAttack: { 
      description: "TBA", 
      action: unleashEnergyBlast // Reference to super attack function
    }
  }
];

   // Define options for each brawler
const brawlerOptions = {
  "Brawler 1": {
    numberOfBullets: 2,
    spread: Math.PI / 24,
    bulletSize: 5,
    bulletSpeed: 5,
    travelPattern: 'straight',
    piercing: false,
    throwable: false,
    bulletWaves: 1, 
    sameDirectionForWaves: true, 
    areaEffect: false,
    areaEffectSize: 0, 
    areaEffectTicks: 0,
    maxAmmo: 3, // Maximum ammo count
    damage: 20,
    bulletRange: 300,
    ammoCooldown: 1000, // Cooldown between each shot (in milliseconds)
    reloadSpeed: 3000, // Time to reload (in milliseconds)
    maxHealth: 100
  },
  "Brawler 2": {
    numberOfBullets: 3,
    spread: Math.PI / 8,
    bulletSize: 8,
    bulletSpeed: 8,
    travelPattern: 'precise diagonal',
    piercing: true,
    throwable: false,
    bulletWaves: 1, 
    sameDirectionForWaves: true, 
    areaEffect: false,
    areaEffectSize: 0, 
    areaEffectTicks: 0,
    maxAmmo: 5,
    damage: 8,
    bulletRange: 300,
    ammoCooldown: 500,
    reloadSpeed: 5000,
    maxHealth: 85
  },
  // Define options for other brawlers as needed
};
    
// Function to start the game
function startGame() {
  document.getElementById("titleScreen").classList.add("hidden");
  document.getElementById("brawlerSelection").classList.remove("hidden");
  showBrawlers();
  
  // Call the function to initially update total trophies display
  updateTotalTrophies();
}

// Function to display brawlers for selection
function showBrawlers() {
  const brawlerList = document.getElementById("brawlerList");
  brawlers.forEach(brawler => {
    const brawlerElement = document.createElement("div");
    brawlerElement.classList.add("brawler");
    brawlerElement.innerHTML = `
      <img src="${brawler.image}" alt="${brawler.name}" title="${brawler.name}" onclick="selectBrawler('${brawler.name}')">
      <p>Main Attack: ${brawler.mainAttack.description}</p>
      <p>Super Attack: ${brawler.superAttack.description}</p>
    `;
    brawlerList.appendChild(brawlerElement);
  });
}



// Function to select a brawler
function selectBrawler(brawlerName) {
  selectedBrawler = brawlers.find(brawler => brawler.name === brawlerName);
  console.log("Selected Brawler:", brawlerName);
  startRound(); // Start the round when a brawler is selected
  startRound2();
}



// Function for passive healing and updating health bars
function passiveHealingAndUpdateHealthBars() {
    playerTotalHealth = brawlerOptions[selectedBrawler.name].maxHealth
    enemyTotalHealth = brawlerOptions[enemyAI.selectedBrawler].maxHealth
  
    // Check if player is not currently attacking and is not at full health
    if (!playerAttacking && playerHealth < playerTotalHealth) {
        // Calculate amount to heal (1/7 of total health)
        const playerHealAmount = Math.ceil(playerTotalHealth / 7);
        // Ensure that healed health does not exceed total health
        playerHealth = Math.min(playerHealth + playerHealAmount, playerTotalHealth);
        // Update player health bar
        updatePlayerHealthBar(playerHealth);
    }

    // Check if enemy is not currently attacking and is not at full health
    if (!enemyAttacking && enemyHealth < enemyTotalHealth) {
        // Calculate amount to heal (1/7 of total health)
        const enemyHealAmount = Math.ceil(enemyTotalHealth / 7);
        // Ensure that healed health does not exceed total health
        enemyHealth = Math.min(enemyHealth + enemyHealAmount, enemyTotalHealth);
        // Update enemy health bar
        updateEnemyHealthBar(enemyHealth);
    }

    // Repeat the passive healing and health bar update process periodically
    setTimeout(passiveHealingAndUpdateHealthBars, 3000);
}





    
let selectedBrawler = null;
let gameStarted = false;
let playerAttacking = false;
let enemyAttacking = false;

function startRound() {
  lastShootTime = 0; // Variable to store the last time a bullet was shot
  ammoCount = brawlerOptions[selectedBrawler.name].maxAmmo; // Initial ammo count
  maxAmmo = brawlerOptions[selectedBrawler.name].maxAmmo; // Maximum ammo count (can vary for each brawler)
  gameStarted = true;
  // Clear any existing HTML content
  document.body.innerHTML = '';
  playerAttacking = false;
  enemyAttacking = false;
    
  // Create ammo bar
  const ammoBar = document.createElement('div');
  ammoBar.id = 'ammoBar';
  ammoBar.textContent = 'Ammo: ';
  for (let i = 0; i < 3; i++) {
    const ammoIcon = document.createElement('span');
    // ammoIcon.classList.add('ammo-icon');
    // ammoIcon.textContent = '●';
    // ammoBar.appendChild(ammoIcon);
  }
  document.body.appendChild(ammoBar);

  // Create health bar
  const healthBar = document.createElement('div');
  healthBar.id = 'healthBar';
  healthBar.textContent = 'Health: ';
  healthProgress = document.createElement('progress');
  healthProgress.value = 100;
  healthProgress.max = 100;
  healthBar.appendChild(healthProgress);
  document.body.appendChild(healthBar);

  // Create health bar
  const enemyHealthBar = document.createElement('div');
  enemyHealthBar.id = 'enemyHealthBar';
  enemyHealthBar.textContent = 'Enemy Health: ';
  enemyHealthProgress = document.createElement('progress');
  enemyHealthProgress.value = 100; // Initial health value
  enemyHealthProgress.max = 100; // Maximum health value
  enemyHealthBar.appendChild(enemyHealthProgress);
  document.body.appendChild(enemyHealthBar);


  
  // Create player element
  const player = document.createElement('div');
  player.id = 'player';
  player.style.width = '30px';
  player.style.height = '30px';
  player.style.backgroundColor = 'blue';
  player.style.position = 'absolute';
  player.style.left = '50px';
  player.style.top = '50px';
  document.body.appendChild(player);

  // Add player movement
  document.addEventListener('keydown', function(event) {
    const step = 10; // Adjust step size as needed
    switch(event.key) {
      case 'ArrowUp':
        movePlayer(0, -step);
        break;
      case 'ArrowDown':
        movePlayer(0, step);
        break;
      case 'ArrowLeft':
        movePlayer(-step, 0);
        break;
      case 'ArrowRight':
        movePlayer(step, 0);
        break;
    }
  });
}

function movePlayer(dx, dy) {
  const player = document.getElementById('player');
  const rect = player.getBoundingClientRect();
  const newX = rect.left + dx;
  const newY = rect.top + dy;
  
  // Prevent player from moving outside the viewport
  if (newX >= 0 && newX <= window.innerWidth - 30) {
    player.style.left = newX + 'px';
  }
  if (newY >= 0 && newY <= window.innerHeight - 30) {
    player.style.top = newY + 'px';
  }
}

// Function to handle keydown events
function handleKeyDown(event) {
    // Prevent default scrolling behavior for arrow keys
    if (event.keyCode >= 37 && event.keyCode <= 40) {
        event.preventDefault();
    }
}

// Add event listener for keydown events
document.addEventListener('keydown', handleKeyDown);
    

document.addEventListener('mousedown', function(event) {
  // Randomize bullet parameters
  const options2 = {
    numberOfBullets: Math.floor(Math.random() * 5) + 1, // Random number of bullets between 1 and 5
    spread: (Math.random() * Math.PI) / 4, // Random spread angle between 0 and 45 degrees (in radians)
    bulletSize: Math.floor(Math.random() * 10) + 5, // Random bullet size between 5 and 15 pixels
    bulletSpeed: Math.floor(Math.random() * 5) + 5, // Random bullet speed between 5 and 10 pixels per frame
    travelPattern: 'straight', // For demonstration, let's keep it straight
    piercing: Math.random() < 0.5, // 50% chance of piercing
    throwable: Math.random() < 0.5, // 50% chance of being throwable
    bulletWaves: Math.floor(Math.random() * 3) + 1, // Random number of bullet waves between 1 and 3
    sameDirectionForWaves: Math.random() < 0.5, // 50% chance of shooting in the same direction for each wave
    areaEffect: Math.random() < 0.5, // 50% chance of having an area effect
    areaEffectSize: Math.floor(Math.random() * 20) + 10, // Random area effect size between 10 and 30
    areaEffectTicks: Math.floor(Math.random() * 5) + 1 // Random number of ticks for area effect between 1 and 5
  };
  
  
  // Start shooting when mouse is down
  shootingInterval = setInterval(function() {
    shootBulletsForBrawler(event, brawlerOptions[selectedBrawler.name]);
  }, 100); // Adjust the interval for bullet shooting speed
});

document.addEventListener('mouseup', function() {
  // Stop shooting when mouse is up
  let playerAttacking = false;
  clearInterval(shootingInterval);
});
    


// Function to update the UI representing the ammo bar
function updateAmmoBar() {
  const ammoBar = document.getElementById('ammoBar');
  ammoBar.style.width = ((ammoCount / maxAmmo) * 50) + '%'; // Update the width of the ammo bar based on the current ammo count
  ammoBar.style.backgroundColor = "orange";
}

    

    
function shootBulletsForBrawler(event, brawler) {
  const options = brawlerOptions[selectedBrawler.name];
  const currentTime = Date.now();
  
  if (currentTime - lastShootTime < options.ammoCooldown || ammoCount <= 0) {
    return; // Check if cooldown time has elapsed and if ammo is available
  }

  // Decrement ammo count
  ammoCount--;

  // Update UI: Decrease ammo bar
  updateAmmoBar();

  // Shoot bullets
  shootBullets(event, options);

  // Record last shoot time
  lastShootTime = currentTime;

  // Check if ammo is depleted and trigger reload if needed
  if (ammoCount < maxAmmo) {
    setTimeout(() => {
      if (ammoCount < maxAmmo) {
        ammoCount += 1; // Increment ammo count by 1
        updateAmmoBar(); // Update UI
      }
    }, options.reloadSpeed); 
  }
}
    
// Function to reload ammo
function reloadAmmo() {
  if (ammoCount < maxAmmo) {
    ammoCount += 1; // Increment ammo count by 1
  } else {
    ammoCount = maxAmmo; // Reset ammo count to maximum
  }
  updateAmmoBar(); // Update UI
}

    
function shootBullets(event, options) {
  // Default bullet options
  const defaultOptions = {
    numberOfBullets: 1,
    spread: Math.PI / 12, // Default spread angle (15 degrees)
    bulletSize: 5,
    bulletSpeed: 5,
    travelPattern: 'straight', // Default travel pattern
    piercing: false,
    throwable: false,
    bulletWaves: 1, // Default number of bullet waves
    sameDirectionForWaves: true, // Default behavior: shoot in the same direction for each wave
    areaEffect: false, // Default behavior: no area effect
    areaEffectSize: 0, // Default area effect size
    areaEffectTicks: 0, // Default number of ticks for area effect
    damage: 20,
    bulletRange: 500 // in pixels
  };

  // Merge default options with provided options
  const bulletOptions = { ...defaultOptions, ...options };

  playerAttacking = true;

  // Create bullets
  for (let wave = 0; wave < bulletOptions.bulletWaves; wave++) {
    const waveSpread = bulletOptions.sameDirectionForWaves ? 0 : (Math.random() * bulletOptions.spread) - (bulletOptions.spread / 2);

    for (let i = 0; i < bulletOptions.numberOfBullets; i++) {
      // Calculate individual spread for each bullet within the wave
      const individualSpread = (i / (bulletOptions.numberOfBullets - 1)) * bulletOptions.spread - (bulletOptions.spread / 2);
      
      // Create a bullet element
      const bullet = document.createElement('div');
      bullet.classList.add('bullet');
      bullet.style.position = 'absolute';
      bullet.style.backgroundColor = 'red';
      bullet.style.width = bulletOptions.bulletSize + 'px';
      bullet.style.height = bulletOptions.bulletSize + 'px';

      // Set the initial position of the bullet (near the player)
      const player = document.getElementById('player');
      const playerRect = player.getBoundingClientRect();
      bullet.style.left = (playerRect.left + playerRect.width / 2 - bulletOptions.bulletSize / 2) + 'px';
      bullet.style.top = (playerRect.top + playerRect.height / 2 - bulletOptions.bulletSize / 2) + 'px';

      // Calculate angle between player and mouse pointer
      const mouseX = event.clientX;
      const mouseY = event.clientY;
      const playerX = playerRect.left + playerRect.width / 2;
      const playerY = playerRect.top + playerRect.height / 2;
      let angle = Math.atan2(mouseY - playerY, mouseX - playerX) + waveSpread;

      // Apply spread if applicable
      if (bulletOptions.numberOfBullets > 1) {
        const spreadIncrement = bulletOptions.spread / (bulletOptions.numberOfBullets - 1);
        angle += (i * spreadIncrement) - (bulletOptions.spread / 2);
      }

      // Set bullet velocity based on chosen travel pattern
      let vx, vy;
      switch (bulletOptions.travelPattern) {
        case 'straight':
          vx = bulletOptions.bulletSpeed * Math.cos(angle);
          vy = bulletOptions.bulletSpeed * Math.sin(angle);
          break;
        case 'precise diagonal':
          vx = bulletOptions.bulletSpeed * Math.cos(angle);
          vy = bulletOptions.bulletSpeed * Math.sin(angle) + Math.sin((angle) * 5) * 2;
          break;
        case 'zigzag':
          // Implement zigzag pattern logic
          vx = bulletOptions.bulletSpeed * Math.cos(angle) + Math.sin(angle * damage) * 2;
          vy = bulletOptions.bulletSpeed * Math.sin(angle) + Math.cos(angle * damage) * 2;
          break;
        case 'homing':
          // Implement homing pattern logic
          vx = bulletOptions.bulletSpeed * Math.cos(angle);
          vy = bulletOptions.bulletSpeed * Math.sin(angle);
          // Calculate angle to enemy
          const enemy = document.getElementById('enemy');
          const enemyRect = enemy.getBoundingClientRect();
          const enemyX = enemyRect.left + enemyRect.width / 2;
          const enemyY = enemyRect.top + enemyRect.height / 2;
          const angleToEnemy = Math.atan2(enemyY - playerY, enemyX - playerX);
          // Adjust velocity to move towards enemy
          const angleDifference = angleToEnemy - angle;
          vx += Math.cos(angleDifference) * 0.5; // Adjust the factor to control the homing strength
          vy += Math.sin(angleDifference) * 0.5; // Adjust the factor to control the homing strength
          break;
        case 'spiral':
          // Implement spiral pattern logic
          const spiralSpeed = 0.1; // Adjust the spiral speed as needed
          const spiralAngle = wave * Math.PI / 6; // Adjust the spiral angle increment as needed
          vx = bulletOptions.bulletSpeed * Math.cos(angle + spiralAngle) + spiralSpeed * angle * Math.cos(angle);
          vy = bulletOptions.bulletSpeed * Math.sin(angle + spiralAngle) + spiralSpeed * angle * Math.sin(angle);
          break;
        case 'random':
          // Implement random direction pattern logic
          vx = bulletOptions.bulletSpeed * Math.cos(angle) + (Math.random() - 0.5) * 5;
          vy = bulletOptions.bulletSpeed * Math.sin(angle) + (Math.random() - 0.5) * 5;
          break;
        default:
          // Default to straight pattern if an invalid pattern is provided
          vx = bulletOptions.bulletSpeed * Math.cos(angle);
          vy = bulletOptions.bulletSpeed * Math.sin(angle);
          break;
      }

      // Add the bullet to the game canvas
      document.body.appendChild(bullet);

      // Track bullet travel distance
      let traveledDistance = 0;

      // Animate the bullet
      const bulletInterval = setInterval(function () {
        // Move the bullet
        const bulletRect = bullet.getBoundingClientRect();
        bullet.style.left = (bulletRect.left + vx) + 'px';
        bullet.style.top = (bulletRect.top + vy) + 'px';

        // Calculate bullet travel distance
        traveledDistance += bulletOptions.bulletSpeed;

        // Check if the bullet reaches its maximum range
        if (traveledDistance >= bulletOptions.bulletRange) {
          // Remove the bullet from the DOM
          bullet.parentNode.removeChild(bullet);
          // Stop the interval
          clearInterval(bulletInterval);
        }

        // Check if the bullet collides with the enemy
        const enemy = document.getElementById('enemy');
        const enemyRect = enemy.getBoundingClientRect();
        if (
          bulletRect.left < enemyRect.right &&
          bulletRect.right > enemyRect.left &&
          bulletRect.top < enemyRect.bottom &&
          bulletRect.bottom > enemyRect.top
        ) {
          // Collision detected, apply damage to the enemy
          applyDamageToEnemy(bulletOptions.damage);

          // Remove the bullet from the DOM
          bullet.parentNode.removeChild(bullet);
          // Stop the interval
          clearInterval(bulletInterval);
        }

        // Check if the bullet is out of bounds
        if (bulletRect.top < 0 || bulletRect.left < 0 || bulletRect.right > window.innerWidth || bulletRect.bottom > window.innerHeight) {
          // Remove the bullet from the DOM
          bullet.parentNode.removeChild(bullet);
          // Stop the interval
          clearInterval(bulletInterval);
        }
      }, 20); // Adjust the interval for bullet speed
    }
  }
  playerAttacking = false;
}

function shootBulletsForEnemy(playerPosition, options, angle) {
  // Default bullet options
  const defaultOptions = {
    numberOfBullets: 1,
    spread: Math.PI / 12, // Default spread angle (15 degrees)
    bulletSize: 5,
    bulletSpeed: 5,
    travelPattern: 'straight', // Default travel pattern
    piercing: false,
    throwable: false,
    bulletWaves: 1, // Default number of bullet waves
    sameDirectionForWaves: true, // Default behavior: shoot in the same direction for each wave
    areaEffect: false, // Default behavior: no area effect
    areaEffectSize: 0, // Default area effect size
    areaEffectTicks: 0, // Default number of ticks for area effect
    damage: 20, // Main attack damage
    bulletRange: 500 // in pixels
  };

  // Merge default options with provided options
  const bulletOptions = { ...defaultOptions, ...options };

  enemyAttacking = true;
  
  // Create bullets
  for (let wave = 0; wave < bulletOptions.bulletWaves; wave++) {
    const waveSpread = bulletOptions.sameDirectionForWaves ? 0 : (Math.random() * bulletOptions.spread) - (bulletOptions.spread / 2);
    
    // Decrement ammo count only once per wave
    if (enemyAI.ammoCount > 0) {
      enemyAI.ammoCount--; // Decrement ammo count
    } else {
      break; // No ammo left, stop shooting
    }
    
    for (let i = 0; i < bulletOptions.numberOfBullets; i++) {
      // Calculate individual spread for each bullet within the wave
      const individualSpread = (i / (bulletOptions.numberOfBullets - 1)) * bulletOptions.spread - (bulletOptions.spread / 2);
      
      // Create a bullet element
      const bullet = document.createElement('div');
      bullet.classList.add('bullet');
      bullet.style.position = 'absolute';
      bullet.style.backgroundColor = 'blue'; // Change color for enemy bullets
      bullet.style.width = bulletOptions.bulletSize + 'px';
      bullet.style.height = bulletOptions.bulletSize + 'px';

      // Set the initial position of the bullet (near the enemy)
      const enemy = document.getElementById('enemy');
      const enemyRect = enemy.getBoundingClientRect();
      bullet.style.left = (enemyRect.left + enemyRect.width / 2 - bulletOptions.bulletSize / 2) + 'px';
      bullet.style.top = (enemyRect.top + enemyRect.height / 2 - bulletOptions.bulletSize / 2) + 'px';

      // Set bullet velocity based on angle with individual spread and travel pattern
      let vx, vy;
      switch (bulletOptions.travelPattern) {
        case 'straight':
          vx = bulletOptions.bulletSpeed * Math.cos(angle + waveSpread + individualSpread);
          vy = bulletOptions.bulletSpeed * Math.sin(angle + waveSpread + individualSpread);
          break;
        case 'precise diagonal':
          vx = bulletOptions.bulletSpeed * Math.cos(angle);
          vy = bulletOptions.bulletSpeed * Math.sin(angle) + Math.sin((angle) * 5) * 2;
          break;
        case 'zigzag':
          // Implement zigzag pattern logic
          vx = bulletOptions.bulletSpeed * Math.cos(angle + waveSpread + individualSpread) + Math.sin((angle + waveSpread + individualSpread) * 5) * 2;
          vy = bulletOptions.bulletSpeed * Math.sin(angle + waveSpread + individualSpread) + Math.cos((angle + waveSpread + individualSpread) * 5) * 2;
          break;
        case 'homing':
          // Implement homing pattern logic
          vx = bulletOptions.bulletSpeed * Math.cos(angle + waveSpread + individualSpread);
          vy = bulletOptions.bulletSpeed * Math.sin(angle + waveSpread + individualSpread);
          // Calculate angle to player
          const player = document.getElementById('player');
          const playerRect = player.getBoundingClientRect();
          const playerX = playerRect.left + playerRect.width / 2;
          const playerY = playerRect.top + playerRect.height / 2;
          const angleToPlayer = Math.atan2(playerY - (enemyY + enemyRect.height / 2), playerX - (enemyX + enemyRect.width / 2));
          // Adjust velocity to move towards player
          const angleDifference = angleToPlayer - (angle + waveSpread + individualSpread);
          vx += Math.cos(angleDifference) * 0.5; // Adjust the factor to control the homing strength
          vy += Math.sin(angleDifference) * 0.5; // Adjust the factor to control the homing strength
          break;
        case 'spiral':
          // Implement spiral pattern logic
          const spiralSpeed = 0.1; // Adjust the spiral speed as needed
          const spiralAngle = wave * Math.PI / 6; // Adjust the spiral angle increment as needed
          vx = bulletOptions.bulletSpeed * Math.cos(angle + waveSpread + individualSpread + spiralAngle) + spiralSpeed * (angle + waveSpread + individualSpread) * Math.cos(angle + waveSpread + individualSpread);
          vy = bulletOptions.bulletSpeed * Math.sin(angle + waveSpread + individualSpread + spiralAngle) + spiralSpeed * (angle + waveSpread + individualSpread) * Math.sin(angle + waveSpread + individualSpread);
          break;
        case 'random':
          // Implement random direction pattern logic
          vx = bulletOptions.bulletSpeed * Math.cos(angle + waveSpread + individualSpread) + (Math.random() - 0.5) * 5;
          vy = bulletOptions.bulletSpeed * Math.sin(angle + waveSpread + individualSpread) + (Math.random() - 0.5) * 5;
          break;
        default:
          // Default to straight pattern if an invalid pattern is provided
          vx = bulletOptions.bulletSpeed * Math.cos(angle + waveSpread + individualSpread);
          vy = bulletOptions.bulletSpeed * Math.sin(angle + waveSpread + individualSpread);
          break;
      }

      // Add the bullet to the game canvas
      document.body.appendChild(bullet);

      // Track bullet travel distance
      let traveledDistance = 0;
      
      // Animate the bullet
      const bulletInterval = setInterval(function() {
        // Move the bullet
        const bulletRect = bullet.getBoundingClientRect();
        bullet.style.left = (bulletRect.left + vx) + 'px';
        bullet.style.top = (bulletRect.top + vy) + 'px';

        // Calculate bullet travel distance
        traveledDistance += bulletOptions.bulletSpeed;
        
        // Check if the bullet reaches its maximum range
        if (traveledDistance >= bulletOptions.bulletRange) {
          // Remove the bullet from the DOM
          bullet.parentNode.removeChild(bullet);
          // Stop the interval
          clearInterval(bulletInterval);
        }

        // Check if the bullet collides with the player
        const player = document.getElementById('player');
        const playerRect = player.getBoundingClientRect();
        if (
          bulletRect.left < playerRect.right &&
          bulletRect.right > playerRect.left &&
          bulletRect.top < playerRect.bottom &&
          bulletRect.bottom > playerRect.top
        ) {
          // Collision detected, apply damage to the player
          applyDamageToPlayer(bulletOptions.damage);
          
          // Remove the bullet from the DOM
          bullet.parentNode.removeChild(bullet);
          // Stop the interval
          clearInterval(bulletInterval);
        }
          
        // Check if the bullet is out of bounds
        if (bulletRect.top < 0 || bulletRect.left < 0 || bulletRect.right > window.innerWidth || bulletRect.bottom > window.innerHeight) {
          // Remove the bullet from the DOM
          bullet.parentNode.removeChild(bullet);
          // Stop the interval
          clearInterval(bulletInterval);
        }
      }, 20); // Adjust the interval for bullet speed
    }
  }
  enemyAttacking = false;
}


    
// Define and initialize enemy's health
let enemyHealth = 100; // Initial health value
let playerHealth = 100;

// Function to update enemy health bar
function updateEnemyHealthBar(health) {
  enemyHealthProgress.value = health;
}

// Function to apply damage to the enemy
function applyDamageToEnemy(damage) {
  // Apply damage to the enemy
  enemyHealth -= damage;

  // Ensure enemy health doesn't go below 0
  if (enemyHealth < 0) {
    enemyHealth = 0;
    gameOver(true);
  }

  // Update enemy health bar
  updateEnemyHealthBar(enemyHealth);

  console.log("Enemy received " + damage + " damage!");
}


    

    
// Function to initialize the AI
function initEnemyAI() {
  // Set initial appearance of the AI (e.g., create HTML element representing the AI)
  const enemyElement = document.createElement('div');
  enemyElement.id = 'enemy';
  enemyElement.style.width = '50px';
  enemyElement.style.height = '50px';
  enemyElement.style.backgroundColor = 'red';
  enemyElement.style.position = 'absolute';
  // Set initial position of the AI (e.g., randomly on the game canvas)
  enemyElement.style.left = Math.random() * (window.innerWidth - 50) + 'px';
  enemyElement.style.top = Math.random() * (window.innerHeight - 50) + 'px';
  document.body.appendChild(enemyElement);
}

// Function to choose a random brawler for the AI
function chooseRandomBrawler() {
  const brawlerNames = Object.keys(brawlerOptions); // Get all brawler names
  const randomIndex = Math.floor(Math.random() * brawlerNames.length);
  return brawlerNames[randomIndex];
}






// Define AI object
// Define initial enemy AI properties
const enemyAI = {
  health: 100,
  maxAmmo: 3,
  ammoCount: 3,
  selectedBrawler: '', // To store the selected brawler
  reloadTime: 3000, // Time it takes to reload (in milliseconds)
  reloading: false // Flag to indicate if the enemy is currently reloading
};

function updateEnemyHealthBar(health) {
  // Update the value of the progress element
  enemyHealthProgress.value = health;

  // Update the width of the progress bar based on the health value
  const percentage = (health / enemyHealthProgress.max) * 100;
  enemyHealthProgress.value = percentage;
}

    
// Function to continuously update enemy AI's movement, shooting, and reloading
function updateEnemyAI2() {
  const player = document.getElementById('player');
  const enemy = document.getElementById('enemy');

  // Calculate angle and distance towards the player
  const playerRect = player.getBoundingClientRect();
  const playerX = playerRect.left + playerRect.width / 2;
  const playerY = playerRect.top + playerRect.height / 2;
  const enemyRect = enemy.getBoundingClientRect();
  const enemyX = enemyRect.left + enemyRect.width / 2;
  const enemyY = enemyRect.top + enemyRect.height / 2;
  const angleToPlayer = Math.atan2(playerY - enemyY, playerX - enemyX);
  const distanceToPlayer = Math.sqrt((playerX - enemyX) ** 2 + (playerY - enemyY) ** 2);

  // Shoot bullets towards the player if the enemy has ammo
  if (enemyAI.ammoCount > 0) {
    const options = brawlerOptions[enemyAI.selectedBrawler];
    shootBulletsForEnemy({ clientX: playerX, clientY: playerY }, options, angleToPlayer);
    enemyAI.ammoCount--; // Decrement ammo count
  } else if (!enemyAI.reloading) { // If out of ammo and not currently reloading
    // Start reloading
    enemyAI.reloading = true;
    setTimeout(() => {
      // Reload complete
      if (enemyAI.ammoCount < enemyAI.maxAmmo) {
        enemyAI.ammoCount += 1; // Increment ammo count by 1
      }
      enemyAI.reloading = false; // Reset reloading flag
    }, enemyAI.reloadTime);
  }

  // Move the enemy towards or away from the player based on distance and health
  const speed = 2; // Adjust enemy movement speed as needed
  const bulletRange = brawlerOptions[selectedBrawler.name].bulletRange;
let dx, dy;
if (enemyHealth <= 50 && distanceToPlayer <= bulletRange + 60) {
  // Move away from player if health is below 50% and player is nearby
  dx = -speed * Math.cos(angleToPlayer);
  dy = -speed * Math.sin(angleToPlayer);
} else {
  // Move towards player
  dx = speed * Math.cos(angleToPlayer);
  dy = speed * Math.sin(angleToPlayer);
}

// Calculate the potential new position
const newLeft = enemyRect.left + dx;
const newTop = enemyRect.top + dy;

// Check if the new position would cause the enemy to go out of bounds
if (
  newLeft >= 0 &&
  newTop >= 0 &&
  newLeft + enemyRect.width <= window.innerWidth &&
  newTop + enemyRect.height <= window.innerHeight
) {
  // Update the enemy's position only if it remains within bounds
  enemy.style.left = newLeft + 'px';
  enemy.style.top = newTop + 'px';
}


  // Shoot bullets towards the player less often if health is below 50%
  if (enemyHealth > 50 || Math.random() > 0.5) {
    const options3 = brawlerOptions[enemyAI.selectedBrawler];
    shootBulletsForEnemy({ clientX: playerX, clientY: playerY }, options3, angleToPlayer);
  }

  // Continue updating enemy AI
  requestAnimationFrame(updateEnemyAI2);
}

    
// Function to start the round and make the AI attack
function startRound2() {
  // Initialize the AI
  initEnemyAI();
  
  // Choose a random brawler for the AI
  enemyAI.selectedBrawler = chooseRandomBrawler();
  // Call the passiveHealingAndUpdateHealthBars function to start the process
  enemyHealth = brawlerOptions[enemyAI.selectedBrawler].maxHealth; // Initial health value
  playerHealth = brawlerOptions[selectedBrawler.name].maxHealth
  passiveHealingAndUpdateHealthBars();
  updateEnemyAI2();
}



function applyDamageToPlayer(damage) {
  // Apply damage to the player
  playerHealth -= damage;

  // Ensure player health doesn't go below 0
  if (playerHealth < 0) {
    playerHealth = 0;
  }

  // Update player health bar
  updatePlayerHealthBar(playerHealth);

  console.log("Player received " + damage + " damage!");

  // Check if player has lost
  if (playerHealth === 0) {
    gameOver(false); // Game over if player's health reaches 0
  }
}

function updatePlayerHealthBar(health) {
    healthProgress.value = health;
}


    
    
    
// Function to set a cookie
function setCookie(name, value, days) {
    const date = new Date();
    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
    const expires = "expires=" + date.toUTCString();
    document.cookie = name + "=" + value + ";" + expires + ";path=/";
}

// Function to get a cookie value by name
function getCookie(name) {
    const cookieName = name + "=";
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
        let cookie = cookies[i];
        while (cookie.charAt(0) == ' ') {
            cookie = cookie.substring(1);
        }
        if (cookie.indexOf(cookieName) == 0) {
            return cookie.substring(cookieName.length, cookie.length);
        }
    }
    return "";
}

// Initialize playerTrophies with the value from the cookie
document.addEventListener('DOMContentLoaded', function() {
    playerTrophies = parseInt(getCookie('playerTrophies')) || 0;
});




// Function to handle game over logic
function gameOver(isVictory) {
  
  
    // Update trophy count based on victory or loss
    if (isVictory) {
        // Increment trophy count by 8 for victory
        playerTrophies += 8;
    } else {
        // Decrement trophy count by 6 for loss
        playerTrophies -= 6;
        // Ensure trophy count does not go below zero
        playerTrophies = Math.max(playerTrophies, 0);
    }
    
    
    
    // Create trophy status element if it doesn't exist
    trophyStatusElement = document.createElement('div');
    trophyStatusElement.id = 'trophyStatus';
    trophyStatusElement.textContent = "Trophies: " + playerTrophies + ". Refresh the page to play again.";
    document.body.appendChild(trophyStatusElement);
  
    // Save trophy count as a cookie
    setCookie('playerTrophies', playerTrophies, 300); // Save for 300 days

    document.getElementById("player").remove();
    document.getElementById("enemy").remove();
    document.getElementById("ammoBar").remove();
    document.getElementById("healthBar").remove();
    document.getElementById("enemyHealthBar").remove();

    // Reset game (example: you can reset player and enemy health, reload ammo, etc.)
    playerHealth = playerTotalHealth; // Reset player health to full
    enemyHealth = enemyTotalHealth; // Reset enemy health to full
    playerAmmoCount = maxAmmo; // Reset player ammo count
    enemyAmmoCount = maxAmmo; // Reset enemy ammo count

    // Reset any other game states or variables as needed
}


    // Function to update total trophies display
function updateTotalTrophies() {
    let totalTrophiesElement = document.getElementById('trophyStatus');
    if (totalTrophiesElement) {
        totalTrophiesElement.textContent = "Total Trophies: " + playerTrophies;
    }
}







function throwGrenades() {
  console.log(selectedBrawler.name + " throws grenades!");
}

function swingSword() {
  console.log(selectedBrawler.name + " swings a sword!");
}

// Placeholder functions for super attacks
function launchRocket() {
  console.log(selectedBrawler.name + " launches a powerful rocket!");
}

function callAirstrike() {
  console.log(selectedBrawler.name + " calls in an airstrike!");
}

function unleashEnergyBlast() {
  console.log(selectedBrawler.name + " unleashes a devastating energy blast!");
}

// Event listener for keyboard input
document.addEventListener('keydown', function(event) {
  // Check if game has started and a brawler is selected
  if (gameStarted && selectedBrawler) {
    // Handle main attack (Space key)
    if (event.code === 'Space') {
      selectedBrawler.mainAttack.action();
    }
    // Handle super attack (Z key)
    else if (event.code === 'KeyZ') {
      selectedBrawler.superAttack.action;
    }
  }

});

    
    
    
    
    
    
</script>
</body>
</html>
